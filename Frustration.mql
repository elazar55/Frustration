#property copyright "Copyright 2017, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

// Input variables
extern int magic_numb  = 1;
extern int training_target = 100;
extern double min_lots = 0.01;
extern double max_lots = 0.01;
extern double tp_pips  = 20;
extern double sl_pips  = 20;
extern int stoch_K = 5;
extern int stoch_S = 3;
extern int stoch_D = 3;
extern int stoch_levels = 30;
extern int cci_period = 14;
extern int cci_levels = 100;
extern int rsi_period = 14;
extern int rsi_levels = 30;
extern int macd_fast = 12;
extern int macd_slow = 26;
extern int macd_ema  = 9;

// Internal state variables
bool buy_trade      = false;
bool sell_trade     = false;
bool in_trade       = false;
bool prev_trade     = false;
double prev_balance = 0;
double price        = 0;
double profit       = 0;
double stoploss     = 0;
double takeprofit   = 0;
int error           = 0;
int points          = 0;
int ticket          = 0;
int consec          = 1;
datetime prev_time = 0;

int OnInit()
{
    UpdateState();
    return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason) {}

double OnTester()
{
    double PROFIT           = TesterStatistics(STAT_PROFIT);
    double TRADES           = TesterStatistics(STAT_TRADES);
    double PROFIT_TRADES    = TesterStatistics(STAT_PROFIT_TRADES);
    double CONPROFIT_TRADES = TesterStatistics(STAT_MAX_CONPROFIT_TRADES);
    
    double confidence = MathSqrt(TRADES) / MathSqrt(training_target);
    if (confidence > 1) confidence = 1;
    
    if (TRADES == 0) return 0;
    return NormalizeDouble((PROFIT_TRADES * 100 / TRADES)  * confidence, 2);
}

void OnTick()
{
    UpdateState();
    
    // Trade once per candle
    if (prev_time == Time[0]) return;
    prev_time = Time[0];

    if (!in_trade)
    {
        // Centers
        int stoch_center = 50;
        int stoch_max = stoch_center + stoch_levels;
        int stoch_min = stoch_center - stoch_levels;
        
        int cci_center = 0;
        int cci_max = cci_center + cci_levels;
        int cci_min = cci_center - cci_levels;
        
        int rsi_center = 50;
        int rsi_max = rsi_center + rsi_levels;
        int rsi_min = rsi_center - rsi_levels;
        //---
    
        // Indicators
        double stoch_signal = iStochastic(NULL, 0, stoch_K, stoch_D, stoch_S, MODE_SMA, 0, MODE_SIGNAL, 1);
        double stoch_main   = iStochastic(NULL, 0, stoch_K, stoch_D, stoch_S, MODE_SMA, 0, MODE_MAIN, 1);
        double cci          = iCCI(NULL, 0, cci_period, PRICE_TYPICAL, 1);
        double rsi          = iRSI(NULL, 0, rsi_period, PRICE_TYPICAL, 1);
        double macd_signal  = iMACD(NULL, 0, macd_fast, macd_slow, macd_ema, PRICE_TYPICAL, MODE_SIGNAL, 1);
        double macd_main    = iMACD(NULL, 0, macd_fast, macd_slow, macd_ema, PRICE_TYPICAL, MODE_MAIN, 1);
        //---
        
        // Orders
        if (stoch_main >= stoch_max && stoch_main <= stoch_signal && macd_main >= 0 && macd_main >= macd_signal && cci >= cci_max && rsi >= rsi_max) SendOrder(OP_SELL);
        if (stoch_main <= stoch_min && stoch_main >= stoch_signal && macd_main <= 0 && macd_main <= macd_signal && cci <= cci_min && rsi <= rsi_min) SendOrder(OP_BUY); 
        //---
    }
}

void UpdateState()
{
    profit     = 0;
    buy_trade  = false;
    sell_trade = false;
    in_trade   = false;
    error      = 0;
    price      = 0;
    stoploss   = 0;
    takeprofit = 0;

    // Loop through all the orders to find ours
    for (int i = 0; i < OrdersTotal(); i++)
    {
        OrderSelect(i, SELECT_BY_POS, MODE_TRADES);

        if (OrderMagicNumber() == magic_numb)
        {
            profit     = OrderProfit();
            price      = OrderOpenPrice();
            in_trade   = true;
            takeprofit = OrderTakeProfit();
            stoploss   = OrderStopLoss();
            ticket     = OrderTicket();

            if (OrderType() == OP_BUY)
            {
                buy_trade  = true;
                sell_trade = false;
            }
            if (OrderType() == OP_SELL)
            {
                buy_trade  = false;
                sell_trade = true;
            }
            break;
        }
    }
    RefreshRates();

    // Trailing stop
    /*double min_stoplevel = MarketInfo(NULL, MODE_STOPLEVEL) * Point;

    if (buy_trade)
    {
        if (Bid >= price + min_stoplevel)
        {
            double new_sl = NormalizeDouble(Bid - min_stoplevel, Digits);

            if (new_sl > stoploss)
            {
                OrderModify(ticket, 0, new_sl, takeprofit, 0, clrNONE);
            }
        }
    }
    if (sell_trade)
    {
        if (Ask <= price - min_stoplevel)
        {
            double new_sl = NormalizeDouble(Ask + min_stoplevel, Digits);

            if (new_sl < stoploss) {
                OrderModify(ticket, 0, new_sl, takeprofit, 0, clrNONE);
            }
        }
    }*/

    // Count trades ended in profit as points for testing
    if (!in_trade && prev_trade)
    {
        if (AccountBalance() > prev_balance)
        {
            points++;
            consec++;
        }
        else if (AccountBalance() < prev_balance)
        {
            points--;
            consec = 1;
        }
    }
    prev_trade   = in_trade;
    prev_balance = AccountBalance();

    // Print state variables
    Comment(
           "\nProfit: "    + DoubleToStr(profit, 2)   + " - " +
           "Consecutive: " + IntegerToString(consec)  + " - " +
           "In Trade: "    + DoubleToStr(in_trade, 0) + " - " +
           "Time: "        + IntegerToString(TimeCurrent() - Time[0])
           );
}

void SendOrder(int OP_TYPE)
{
    int slip       = 0;
    string comment = "Magic Number: " + IntegerToString(magic_numb);
    double lots    = min_lots * consec;
    in_trade = true;

    if (lots > max_lots)
        lots = max_lots;

    RefreshRates();
    if (OP_TYPE == OP_SELL)
    {
        sell_trade = true;
        buy_trade  = false;

        double take_profit = NormalizeDouble(Bid - tp_pips * Point, Digits);
        double stop_loss   = NormalizeDouble(Ask + sl_pips * Point, Digits);

        error = OrderSend(Symbol(), OP_TYPE, lots, Bid, slip, stop_loss, take_profit, comment, magic_numb, 0, clrRed);
    }
    if (OP_TYPE == OP_BUY)
    {
        sell_trade = false;
        buy_trade  = true;

        double take_profit = NormalizeDouble(Ask + tp_pips * Point, Digits);
        double stop_loss   = NormalizeDouble(Bid - sl_pips * Point, Digits);

        error = OrderSend(Symbol(), OP_TYPE, lots, Ask, slip, stop_loss, take_profit, comment, magic_numb, 0, clrLimeGreen);
    }
}
